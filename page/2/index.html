<!DOCTYPE html>





<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="generator" content="Hexo 3.9.0">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    search: {
      root: '/',
      path: ''
    },
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="Do one thing at a time, and do well.">
<meta property="og:type" content="website">
<meta property="og:title" content="Noob">
<meta property="og:url" content="http://jeffzzf.github.io/page/2/index.html">
<meta property="og:site_name" content="Noob">
<meta property="og:description" content="Do one thing at a time, and do well.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Noob">
<meta name="twitter:description" content="Do one thing at a time, and do well.">
  <link rel="canonical" href="http://jeffzzf.github.io/page/2/">


<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Noob</title>
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Noob</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
    <ul id="menu" class="menu">
        
        
        
          
          <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
    </ul>
    

</nav>

</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/09/18/Skiplist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/18/Skiplist/" class="post-title-link" itemprop="url">Skiplist</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-18 10:41:03 / 修改时间：10:47:16" itemprop="dateCreated datePublished" datetime="2019-09-18T10:41:03+08:00">2019-09-18</time>
            </span>
          
            

            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/跳表/" itemprop="url" rel="index"><span itemprop="name">跳表</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>跳跃表是链表的一种变形，具有二分查找的功能。跳跃表的每一层都是一条有序的链表，查找次数近似于层数，时间复杂度为O(logn)，插入、删除也为O(logn)。最底层的链表包含所有元素，它是一种随机化的数据结构（通过抛硬币来决定层数），空间复杂度为 O(n)</p>
<p>红黑树插入、删除节点时，通过调整结构来保持红黑树的平衡，比起跳跃表直接通过一个随机数来决定跨越几层，在时间复杂度的花销高于跳跃表。</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/09/17/晋升大纲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/17/晋升大纲/" class="post-title-link" itemprop="url">未命名</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-17 19:10:53" itemprop="dateCreated datePublished" datetime="2019-09-17T19:10:53+08:00">2019-09-17</time>
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="排队金刚位"><a href="#排队金刚位" class="headerlink" title="排队金刚位"></a>排队金刚位</h2>
          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/09/11/Redis知识点整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/11/Redis知识点整理/" class="post-title-link" itemprop="url">Redis知识点整理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-11 14:19:58" itemprop="dateCreated datePublished" datetime="2019-09-11T14:19:58+08:00">2019-09-11</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-26 13:01:38" itemprop="dateModified" datetime="2019-11-26T13:01:38+08:00">2019-11-26</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/存储/" itemprop="url" rel="index"><span itemprop="name">存储</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/存储/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="缓存的用途"><a href="#缓存的用途" class="headerlink" title="缓存的用途"></a>缓存的用途</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>用户直接访问数据库时，需要从硬盘上读取数据，速度较慢。如果将用户查询数据库中的数据存在缓存中，下次可以直接从内存的缓存中读取，性能更高。</p>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>直接操作缓存能承受的请求远远大于直接访问数据库，将数据库中的数据存放在缓存中能显著提高系统的并发能力</p>
<h2 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h2><p>Redis常见的数据结构包括：String、List、Set、SortedSet、Hash、HyperLogLog</p>
<p>Redis支持的数据结构可以与Java中对应的类来理解，String对应Object类，因为任意对象都可以以string的形式来存储。List数据结构对应java.util.List接口的实现类LinkedList，Set数据结构对应HashSet类，SortedSet对应SortedSet接口，Hash数据结构对应HashMap类。</p>
<p><strong>string</strong>：最基础的数据类型，Redis中String类型的value最多可容纳数据长度为512M。适用于value较小、模型简单的value。</p>
<p><strong>List</strong>：按插入顺序排序的字符串链表。可以在头部（left）和尾部（right）添加新元素。头尾添加元素效率很高，中间插入效率较低。适用于新闻列表、评论列表等列表类型数据存储。</p>
<p><strong>Set</strong>：无序字符串集合，不允许出现重复元素，多次添加相同元素，Set只保存一份数据。适用于存放唯一性数据，如统计访问IP</p>
<p><strong>SortedSet</strong>：与Set相似，都是不重复字符串集合。SortedSet中每个成员都有一个分数（score）与之关联，Redis根据分数为集合中的元素进行从小到大的排序。尽管SortedSet中的成员必须是唯一的，但分数却可以重复。在SortedSet中添加、删除或更新元素的事件复杂度为O(logn)。适用于积分排行榜等需要排序的场景，SortedSet中元素个数不要超过1w。</p>
<p><strong>Hash</strong>：用于存储值对象数据，如User对象的Username、Password、Age等属性，可以部分更新、获取，提高效率。</p>
<p><strong>HyperLogLog</strong>：用于基数统计，可以使用少量固定大小的内存统计集合中唯一元素的数量（每个HyperLogLog占用12KB内存，可统计$2^{64}$个不同元素。HyperLogLog得到的基数统计不是精确值，而是一个带有0.81%标准差（standard error）的近似值。适用于统计精确度要求不高的场景，如网站的uv。</p>
<h2 id="Redis和memcached的区别"><a href="#Redis和memcached的区别" class="headerlink" title="Redis和memcached的区别"></a>Redis和memcached的区别</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>memcached仅支持字符串类型，redis支持五种常见数据结构</p>
<h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>redis支持两种持久化策略：RDB快照和AOF日志，memcached不支持持久化</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>memcached不支持分布式，只能通过在客户端使用一致性hash来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点</p>
<p>redis cluster实现了分布式的支持</p>
<h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><p>redis中并不是所有数据都一直存储在内存中，可以将一些很久没用的value交换到磁盘，memcached的数据会一直在内存中</p>
<p>memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。这种方式会导致内存利用率不高</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>redis只使用单核，memcached可以使用多核，平均每个核上存储小数据时redis比memcached性能更好，在100k以上的数据中，memecached性能高于redis。</p>
<h2 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h2><p>Redis支持两种数据持久化方式：RDB快照和AOF日志。两种持久化方式可以单独使用，但通常会将两者结合起来。 </p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>将Redis在内存的数据库记录定时dump到磁盘上的RDB的持久化。指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<h3 id="AOF（append-only-file）持久化"><a href="#AOF（append-only-file）持久化" class="headerlink" title="AOF（append only file）持久化"></a>AOF（append only file）持久化</h3><p>将redis的操作日志以追加的方式写入文件，以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本方式记录，可以打开文件看到详细的操作记录。</p>
<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>设置过期时间后，redis通过两种手段对过期key进行删除：定期删除和惰性删除</p>
<p><strong>定期删除</strong>：redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。</p>
<p><strong>惰性删除</strong>：定期删除可能导致很多过期key到了时间并没有被删除掉，所以就有了惰性删除。惰性删除是在查询时检查key是否已过期，如果过期才删除。</p>
<h2 id="淘汰机制"><a href="#淘汰机制" class="headerlink" title="淘汰机制"></a>淘汰机制</h2><p>由于过期时间的定期删除和惰性删除并不能保证删除所有过期数据，如果大量过期key堆积在内存中，会导致内存很快耗尽，这时需要redis的淘汰机制。</p>
<p>redis提供了6种淘汰策略：</p>
<p><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p>
<p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选要过期的数据淘汰</p>
<p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p>
<p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（最常用）</p>
<p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p>
<p><strong>no-eviction</strong>：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错</p>
<p>4.0版本后增加以下两种：</p>
<p><strong>volatile-lfu</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</p>
<p><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</p>
<h2 id="缓存问题解决"><a href="#缓存问题解决" class="headerlink" title="缓存问题解决"></a>缓存问题解决</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存同一时间大面积失效或部分redis机器宕机，导致所有请求都去查数据库，进而导致数据库CPU和内存负载过高，甚至宕机。为了解决缓存雪崩的问题，可以采取以下几种方法：</p>
<ol>
<li><h4 id="采用高可用缓存"><a href="#采用高可用缓存" class="headerlink" title="采用高可用缓存"></a>采用高可用缓存</h4><p>缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器甚至机房宕掉，依然可以提供服务。例如Redis Sentinel和Redis Cluster都实现了高可用。</p>
</li>
<li><h4 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h4><p>使用ehcache等本地缓存存放部分数据，或对源服务进行限流、熔断、降级等，保证系统核心服务可用</p>
</li>
<li><h3 id="备份和预热"><a href="#备份和预热" class="headerlink" title="备份和预热"></a>备份和预热</h3><p>redis数据备份和恢复，快速预热缓存，设置随机过期时间</p>
</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>查询一个不存在的数据，如redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，将导致这个不存在的数据每次请求都到数据库去查，造成缓存穿透。为了解决缓存穿透，可以设置一个默认值到缓存，第二次从缓存中查询数据就有值了，不用访问数据库。设置一个过期时间或者有值的时候将缓存中的值替换掉即可。另外可以在查询前过滤不符合规则的查询。</p>
<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>只读缓存一般没有什么问题，一旦涉及数据更新，就可能出现缓存和数据库间的数据一致性问题。</p>
<ol>
<li><p>可以通过设置过期时间保证最终一致性。所有写操作以数据库为准，只要达到缓存过期时间，后面的读请求会从数据库中读取然后写入缓存。</p>
</li>
<li><p>使用binlog同步的方式，先将全部数据一次性写入redis，然后mysql发生增删改时通过binlog对redis中的数据进行更新</p>
</li>
</ol>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>redis是纯内存操作，CPU不是redis的瓶颈，它的瓶颈最可能是机器内存的大小或网络带宽。既然单线程容易实现并且CPU不会成为瓶颈，就顺理成章地采用单线程方案了。</p>
<p>采用单线程的好处</p>
<ol>
<li>不需要各种锁的性能开销，在单线程场景下，不用考虑加锁释放锁的操作，也不用考虑可能出现死锁导致的性能消耗</li>
<li>采用单线程避免了不必要的上下文切换和竞争条件，也不存在多进程或多线程导致的切换而消耗CPU。需要发挥多核CPU性能时可以通过在单机开多个Redis实例。</li>
</ol>
<p>redis内部使用文件事件处理器file event handler，这个事件处理器是单线程的，所以redis才叫做单线程的模型。它采用IO多路复用机制，同时监听多个socket，将产生的socket压入内存队列中，事件分派器根据socket上的事件类型来选择对应的事件处理器进行处理。文件事件处理器包含4个部分：</p>
<ul>
<li>多个socket</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但IO多路复用程序会监听多个socket，将产生事件的scoket放入队列中排队，事件分派处理器每次从队列中取出一个socket，根据socket的事件类型交给对应的事件处理器进行处理。</p>
<h2 id="redis-高可用"><a href="#redis-高可用" class="headerlink" title="redis 高可用"></a>redis 高可用</h2><p>Redis 中实现高可用的手段包括持久化、复制、哨兵和集群。</p>
<p><strong>持久化</strong>：持久化是最简单的高可用方法，它的作用是数据备份，即将数据存在硬盘上，保证数据不会因为进程退出而丢失</p>
<p><strong>复制</strong>：复制是高可用 Redis 的基础，哨兵和集群都是在复制的基础上实现高可用的。复制主要实现了数据的多机备份以及对读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机限制</p>
<p><strong>哨兵</strong>：在复制基础上，哨兵实现了自动化的故障恢复，缺陷是写操作无法负载均衡，存储能力受到单机限制</p>
<p><strong>集群</strong>：通过集群，Redis 解决了写操作无法负载均衡以及存储能力受到单机限制的问题，实现了较为完善的高可用方案</p>
<p>Redis Sentinel 是 Redis 高可用的实现方案，Sentinel 是一个管理多个 redis 实例的工具，可以实现对 Redis 的监控、通知、自动故障转移。Redis Sentinel 的基本概念如下：</p>
<p>基本名词说明：</p>
<table>
<thead>
<tr>
<th align="left">基本名词</th>
<th align="left">逻辑结构</th>
<th align="left">物理结构</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Redis数据节点</td>
<td align="left">主节点和从节点</td>
<td align="left">主节点和从节点的进程</td>
</tr>
<tr>
<td align="left">主节点(master)</td>
<td align="left">Redis主数据库</td>
<td align="left">一个独立的Redis进程</td>
</tr>
<tr>
<td align="left">从节点(slave)</td>
<td align="left">Redis从数据库</td>
<td align="left">一个独立的Redis进程</td>
</tr>
<tr>
<td align="left">Sentinel节点</td>
<td align="left">监控Redis数据节点</td>
<td align="left">一个独立的Sentinel进程</td>
</tr>
<tr>
<td align="left">Sentinel节点集合</td>
<td align="left">若干Sentinel节点的抽象组合</td>
<td align="left">若干Sentinel节点进程</td>
</tr>
<tr>
<td align="left">Redis Sentinel</td>
<td align="left">Redis高可用实现方案</td>
<td align="left">Sentinel节点集合和Redis数据节点进程</td>
</tr>
<tr>
<td align="left">应用客户端</td>
<td align="left">泛指一个或多个客户端</td>
<td align="left">一个或者多个客户端进程或者线程</td>
</tr>
</tbody></table>
<p>Redis Sentinel主要功能</p>
<p>Sentinel 的主要功能包括主节点存活检测、主从运行情况检测、自动故障转移（failover）、主从切换，sentinel 最小配置为一主一从。sentinel 系统可以管理多个 Redis 服务器并执行以下任务：</p>
<p><strong>监控</strong>：不断检查主服务器和从服务器是否正常运行</p>
<p><strong>通知</strong>：当被监控的某个 Redis 服务器出现问题时，sentinel 通过 API 脚本向管理员或其它应用程序发送通知</p>
<p><strong>故障自动转移</strong>：当从节点不能正常工作时，sentinel 会开始一次自动的故障转移操作，将与主节点是主从关系的其中一个从节点升级为新的主节点，并将其它从节点指向新的主节点</p>
<p><strong>配置提供者</strong>：Redis sentinel 模式下，客户端应用在初始化时连接的是 sentinel 节点集合，从中获取主节点信息</p>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><p>默认情况下，每个 sentinel 节点以每秒一次的频率对 redis 节点和其它 sentinel 节点发送 ping 命令，并通过节点的回复来判断节点是否在线</p>
<h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>主观下线适用于所有的主节点和从节点，如果在 down-after-milliseconds 毫秒内，sentinel 没有收到目标节点的有效回复，会判定该节点为主观下线</p>
<h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>客观下线只适用于主节点，如果主节点出现故障，sentinel 节点会通过 sentinel is-master-down-by-addr 命令，向其它 sentinel 节点询问对该节点的状态判断。如果超过<quorum>个数的节点判定主节点不可达，则该 sentinel 节点会判断主节点为客观下线。</quorum></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">Redis哨兵模式与高可用集群</a></li>
<li><a href="https://mp.weixin.qq.com/s/jWac1e2yomTHLFICi0ZmuA" target="_blank" rel="noopener">深度掌握Redis</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/09/04/Java并发知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/04/Java并发知识点/" class="post-title-link" itemprop="url">Java并发知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-04 16:34:42" itemprop="dateCreated datePublished" datetime="2019-09-04T16:34:42+08:00">2019-09-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-16 15:52:32" itemprop="dateModified" datetime="2019-12-16T15:52:32+08:00">2019-12-16</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/并发/" itemprop="url" rel="index"><span itemprop="name">并发</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h3><ul>
<li>通过复用线程减少创建和销毁线程的资源消耗</li>
<li>不用重新创建线程，提高响应速度</li>
<li>方便管理，线程是系统稀缺资源，如果无限制创建会消耗系统资源，降低稳定性。使用线程池可以进行统一分配、调优和监控</li>
</ul>
<h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>corePoolSize</strong>: 线程池核心线程数</li>
<li><strong>maximumPoolSize</strong>：线程池最大线程数大小</li>
<li><strong>keepAliveTime</strong>：线程池中非核心线程空闲的存活时间</li>
<li><strong>unit</strong>：线程空闲存活时间单位</li>
<li><strong>workQueue</strong>：存放任务的阻塞队列</li>
<li><strong>threadFactory</strong>：创建线程的工厂，可以给创建的线程设置有意义的名字，便于排查问题</li>
<li><strong>handler</strong>：线程池的饱和策略</li>
</ul>
<h3 id="线程池执行"><a href="#线程池执行" class="headerlink" title="线程池执行"></a>线程池执行</h3><ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了, 并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li>Runnable 或 Callable 中使用 try/catch 捕获并处理异常</li>
<li>submit 提交任务, Feature.get() 处理异常</li>
<li>Executors实例化时传入自己的ThreadFactory设置Thread.setUncaughtExceptionHandler处理异常</li>
<li>重写 ThreadPoolExecutor.afterExecute() 方法, 处理传递的 Throwable.</li>
</ol>
<h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><ul>
<li><strong>ArrayBlockingQueue</strong>(有界队列): 用一个数组实现的有界阻塞队列, FIFO 排序</li>
<li><strong>LinkedBlockingQueue</strong>(可设置容量的队列):基于链表的阻塞队列, FIFO 排序，容量可设置，否则是无边界队列，最大长度 Integer.MAX_VALUE，Executors.newFixedThreadPool线程池使用了这个队列。</li>
<li><strong>DelayQueue</strong>：延迟队列，任务定时周期的延迟执行队列，根据定时的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列</li>
<li><strong>PriorityBlockingQueue</strong>：优先级队列，具有优先级的无界阻塞队列</li>
<li><strong>SynchronousQueue</strong>：同步队列，不存储元素的阻塞队列，每个插入操作必须等另一个线程调用移除操作，否则插入操作一直处于阻塞状态，newCachedThreadPool使用了这个队列</li>
</ul>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><ul>
<li><p>RUNNING</p>
<p>该状态的线程池会接受新任务，并处理阻塞队列中的任务</p>
<p>调用线程池的 shutdown()方法，可以切换到 SHUTDOWN 状态</p>
<p>调用线程池的 shutdownNow() 方法，可以切换到 STOP 状态</p>
</li>
<li><p>SHUTDOWN</p>
<p>该状态的线程池不会接受新任务，但会处理阻塞队列中的任务</p>
<p>队列为空，并且线程池中执行的任务也为空，进入 TIDYING 状态</p>
</li>
<li><p>STOP</p>
<p>该状态线程不会接收新任务，也不会处理阻塞队列中的任务，并且会中断正在运行的任务</p>
<p>返回阻塞队列中正在执行的任务，进入 TIDYING 状态</p>
</li>
<li><p>TIDYING</p>
<p>该状态表明所有的任务已经运行终止，记录的任务数量为 0</p>
<p>terminated()执行完毕，进入 TERMINATED 状态</p>
</li>
<li><p>TERMINATED</p>
<p>该状态表示线程池彻底终止</p>
</li>
</ul>
<h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p>对于计算密集型任务，一个有 N 个处理器的系统通过使用 N+1 个线程的线程池来获得最优的利用率（计算密集型任务巧合在某时刻因为发生一个页错误或因为其他原因暂停，刚好有一个额外的线程，可以确保这种情况下 CPU 周期不会中断工作）。</p>
<p>对于包含了 I/O 和其他阻塞操作的任务，不是所有的线程都会在所有的时间被调度，为了正确设置线程池长度，需要估算任务花在等待的时间与用来计算的时间的比率；最优池大小为：CPU 数目 * 目标 CPU 使用率 * （1 + 等待时间/计算时间）</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/1v-HJikfmEUoaERpTAq3VQ" target="_blank" rel="noopener">Java线程池解析</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/09/02/Spring中的设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/02/Spring中的设计模式/" class="post-title-link" itemprop="url">Spring中的设计模式</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-02 21:40:31" itemprop="dateCreated datePublished" datetime="2019-09-02T21:40:31+08:00">2019-09-02</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-03 11:58:13" itemprop="dateModified" datetime="2019-09-03T11:58:13+08:00">2019-09-03</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-Web/" itemprop="url" rel="index"><span itemprop="name">Java Web</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-Web/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>Spring工厂模式通过BeanFactory或ApplicationContext创建对象，BeanFactory仅提供最基本的依赖注入支持，ApplicationContext扩展了BeanFactory，除了具有BeanFactory的功能外还有更多额外功能，因此一般使用ApplicationContext。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的好处：</p>
<ol>
<li>减少创建对象花费的时间，对于频繁使用的重量级对象来说，是非常可观的系统开销</li>
<li>由于new操作的次数减少，系统内存的使用频率也会降低，可以降低GC压力，缩短GC停顿时间</li>
</ol>
<p>Spring中bean的默认作用域是singleton的，它通过ConcurrentHashMap实现单例模式。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>AOP（Aspect Oriented Programming，面向切面编程）将那些与业务无关的、被业务模块共同调用的逻辑（事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，有利于未来的可扩展性和可维护性。</p>
<p>Spring AOP基于动态代理，如果要代理的对象实现了某个接口，Spring AOP会使用JDK Proxy创建代理对象，对于没有实现接口的对象，无法使用JDK Proxy进行代理，Spring AOP会使用Cglib生成被代理对象的子类来作为代理。</p>
<p>也可以使用AspectJ在编译时做静态代理，这种代理方式基于字节码操作（Bytecode Manipulation）。</p>
<h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><p>模版模式是一种行为设计模式，它定义一个操作中的算法框架，将一些步骤延迟到子类中。模版模式使得子类在不改变算法结构的情况下定义该算法的某些特定步骤的实现方式。</p>
<p>Spring中jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类就使用了模版模式。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是一种对象行为型模式，表示一种对象与对象之间具有依赖关系，当一个对象发生改变时，这个对象所依赖的对象也会做出反应。spring观察者模式流程如下：</p>
<ol>
<li>定义一个事件：实现一个继承自<code>ApplicationEvent</code>，并且写相应的构造函数</li>
<li>定义一个事件监听者：实现<code>ApplicationListener</code>接口，重写<code>onApplicationEvent()</code>方法</li>
<li>使用事件发布消息：通过<code>ApplicationEventPublisher</code>的<code>publishEvent()</code>方法发布消息</li>
</ol>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式（Adapter Pattern）将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的类一起工作。</p>
<h3 id="Spring-AOP中的适配器模式"><a href="#Spring-AOP中的适配器模式" class="headerlink" title="Spring AOP中的适配器模式"></a>Spring AOP中的适配器模式</h3><p>Spring AOP的增强或通知（Advice）使用了适配器模式，接口是AdvisorAdapter。Advice常用类型有BeforeAdvice（目标方法前，前置通知）、AfterAdvice（目标方法调用后，后置通知）、AfterReturningAdvice（目标方法执行结束后，return之前）等。每个类型Advice（通知）都有对应的拦截器： <code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<h3 id="Spring-MVC中的设计模式"><a href="#Spring-MVC中的设计模式" class="headerlink" title="Spring MVC中的设计模式"></a>Spring MVC中的设计模式</h3><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p>
<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code>直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line"> ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p>
<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://snailclimb.top/JavaGuide/#/system-design/framework/spring/Spring-Design-Patterns" target="_blank" rel="noopener">Spring中的设计模式</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/08/31/Spring源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/31/Spring源码/" class="post-title-link" itemprop="url">Spring源码</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-31 14:35:21" itemprop="dateCreated datePublished" datetime="2019-08-31T14:35:21+08:00">2019-08-31</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-04 20:00:53" itemprop="dateModified" datetime="2019-09-04T20:00:53+08:00">2019-09-04</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-Web/" itemprop="url" rel="index"><span itemprop="name">Java Web</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-Web/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>BeanFactory是Bean的容器，Bean在代码层面可以认为是BeanDefinition的实例。BeanDefinition中保存了Bean信息，如这个Bean指向哪个类、是否是单例、是否懒加载、依赖了哪些Bean等。</p>
<p>读取配置的操作在XmlBeanDefinitionReader中，它负责加载配置和解析。</p>
<p>如果是普通bean，直接返回sharedInstance，如果是factoryBean，返回它创建的那个实例对象</p>
<p>创建Bean容器</p>
<p>初始化Bean</p>
<ul>
<li><input disabled type="checkbox"> factoryBean</li>
</ul>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/08/29/SpringMVC原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/29/SpringMVC原理/" class="post-title-link" itemprop="url">Spring IoC原理</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-29 17:21:48" itemprop="dateCreated datePublished" datetime="2019-08-29T17:21:48+08:00">2019-08-29</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-02 11:58:35" itemprop="dateModified" datetime="2019-09-02T11:58:35+08:00">2019-09-02</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-Web/" itemprop="url" rel="index"><span itemprop="name">Java Web</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java-Web/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>Servlet是基于Java技术的Web组件，由容器托管，用于生成动态内容。与其它基于Java的组件技术一样，Servlet也基于平台无关的Java类格式，被编译为平台无关的字节码，可以被基于Java技术的web server动态加载并运行。客户端通过Servlet容器实现的请求/应答模型与Servlet交互。</p>
<p>Servlet容器是web server或application server的一部分，提供基于请求/响应发送模型的网络服务，解码基于MIME的请求，并格式化基于MIME的响应。Servlet容器也包含了管理Servlet生命周期。</p>
<p>典型事件序列如下：</p>
<ol>
<li>客户端（如web浏览器）发送一个HTTP请求到web服务器</li>
<li>Web服务器接收到请求并交给servlet容器处理，servlet容器可以运行在与宿主web服务器同一个进程中，也可以是同一主机的不同进程，或位于不同主机的web服务器中对请求进行处理。</li>
<li>servlet容器根据servlet配置选择相应的servlet，并带上请求和响应参数调用它</li>
<li>servlet执行业务逻辑，然后动态产生响应内容发送回客户端，发送数据到客户端是通过响应对象完成的</li>
<li>一旦servlet完成请求处理，servlet容器必须确保响应正确刷出，并将控制权还给宿主web服务器</li>
</ol>
<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>Servlet按照严格定义的生命周期被管理，该生命周期定义了Servlet如何被加载、实例化、初始化、处理客户端请求，以及何时结束服务。</p>
<ol>
<li>加载和实例化</li>
</ol>
<p>Servlet容器负责加载和实例化Servlet，加载和实例化可以发生在容器启动时，或延迟初始化直到有请求需要处理时。Servlet容器使用普通的Java类加载器加载Servlet类。可以从本地文件系统、远程文件系统或其它网络服务加载。</p>
<ol start="2">
<li>初始化</li>
</ol>
<p>初始化的目的是使Servlet能读取持久化配置数据，初始化一些代价高的资源（如JDBC连接）或执行一些一次性动作。容器调用Servlet实例的init方法完成初始化。</p>
<ol start="3">
<li>请求处理</li>
</ol>
<p>完成初始化后，Servlet就可以开始处理客户端请求了，Request和Response（HTTP场景下对应HttpServletRequest和HttpServletResponse）由容器通过参数传递到Servlet的service方法。</p>
<ol start="4">
<li>终止服务（End of service）</li>
</ol>
<p>当Servlet容器确定servlet应该从服务中移除时，将调用Servlet接口的destory方法释放它使用的任何资源和保存任何持久化状态。容器调用destory方法之前，必须让正在执行的service方法执行完或者超过服务器定义的时间限制。destory方法完成后，容器释放servlet实例以便被垃圾回收。</p>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring-mvc支持Spring容器与MVC容器共存，Spring容器即根容器，mvc容器将根容器视为父容器。Spring容器以下列形式进行配置（web.xml).</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据Servlet规范，组件加载顺序为listener-&gt;filter-&gt;servlet。如果spring根容器存在，它被保存在ServletContext中，key为<code>WebApplicationContext.class.getName()+&quot;.ROOT&quot;</code>。</p>
<p>Spring MVC处理请求流程：</p>
<ol>
<li>客户端发送请求，容器将请求转发给DispatchServlet（web.xml中配置，DispatchServlet.initStrategies()中初始化）</li>
<li>DispatchServlet根据请求信息调用Handlemapping，解析请求到对应的处理执行链（HandlerExecutionChain）</li>
<li>按照interceptor.preHandle() -&gt; handler(由handlerAdapter适配器处理，适配器模式) -&gt; interceptor.postHandle() 的顺序执行</li>
<li>完成执行链后，返回ModelAndView对象，Model是返回的数据对象，View是逻辑上的View</li>
<li>ViewResolver根据逻辑View查找实际的View</li>
<li>DispaterServlet把返回的Model传给View（视图渲染）</li>
<li>把View返回给客户端</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://zhanjindong.com/assets/pdf/Servlet3.1-Specification.pdf" target="_blank" rel="noopener">Servlet 3.1规范</a></li>
<li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/spring-mvc.md" target="_blank" rel="noopener">Spring MVC源码</a></li>
<li><a href="https://snailclimb.top/JavaGuide/#/system-design/framework/spring/SpringMVC-Principle" target="_blank" rel="noopener">Spring MVC原理</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/08/25/tensorflow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/25/tensorflow/" class="post-title-link" itemprop="url">tensorflow</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-25 18:05:39" itemprop="dateCreated datePublished" datetime="2019-08-25T18:05:39+08:00">2019-08-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-05-15 13:06:35" itemprop="dateModified" datetime="2020-05-15T13:06:35+08:00">2020-05-15</time>
              </span>
            
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <p>TensorFlow读取数据的方式主要有2种，一般选择错误会造成性能问题，两种方式为：</p>
<ol>
<li><p>Feed_dict 通过feed_dict将数据喂给session.run函数，这种方式的好处是思路很清晰，易于理解。缺点是性能差，性能差的原因是feed给session的数据需要在session.run之前准备好，如果之前这个数据没有进入内存，那么就需要等待数据进入内存，而在实际场景中，这不仅仅是等待数据从磁盘或者网络进入内存的事情，还可能包括很多前期预处理的工作也在这里做，所以相当于一个串行过程。而数据进入内存后，还要串行的调用PyArrayToTF_Tensor，将其copy成tensorflow的tensorValue。此时，GPU显存处于等待状态，同时，由于tf的Graph中的input为空，所以CPU也处于等待状态，无法运算。</p>
</li>
<li><p>RecordReader 这种方式是tf在Graph中将读取数据这个操作看做图中一个operation节点，减少了一个copy的过程。同时，在tf中还有batch与threads的概念，可以异步的读取数据，保证在GPU或者CPU进行计算的时候，读取数据这个操作也可以多线程异步执行。静态图中各个节点间的阻塞：在一个复杂的DAG计算图中，如果有一个点计算比较慢时，会造成阻塞，下游节点不得不等待。此时，首先要考虑的问题是图中节点参数所存储的位置是否正确。比如如果某个计算节点是在GPU上运算，那么如果这个节点所有依赖的variable对象声明在CPU上，那么就要做一次memcpy，将其从内存中copy到GPU上。因为GPU计算的很快，所以大部分时间花在拷贝上了。总之，如果网络模型比较简单，那么这种操作就会非常致命；如果网络结构复杂，比如网络层次非常深，那么这个问题倒不是太大的问题了。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://tech.meituan.com/2018/06/07/searchads-dnn.html" target="_blank" rel="noopener">深度学习在美团搜索广告排序的应用实践</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/08/20/面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/20/面试题/" class="post-title-link" itemprop="url">面试题</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-20 15:36:45" itemprop="dateCreated datePublished" datetime="2019-08-20T15:36:45+08:00">2019-08-20</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 11:23:45" itemprop="dateModified" datetime="2019-08-29T11:23:45+08:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ol>
<li>Object有哪些方法</li>
<li>Java内存模型（Happends before）</li>
<li>JVM运行时数据区</li>
<li>垃圾收集算法，垃圾收集器</li>
<li>类加载机制</li>
</ol>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ol>
<li>HashMap底层实现，1.8之前之后有什么区别</li>
</ol>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ol>
<li>synchronized和ReenterLock的区别</li>
<li>有哪几种线程池，各自的使用场景是什么，如何创建一个线程池</li>
<li>volatile原理，使用场景</li>
</ol>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ol>
<li>Python有哪些内置的数据结构</li>
<li>如何管理内存</li>
<li>垃圾回收机制</li>
<li>django执行http请求的流程</li>
<li>django内建缓存机制</li>
</ol>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ol>
<li>TCP和UDP的区别</li>
<li>TCP三次握手，四次挥手</li>
<li>TCP可靠性原理</li>
<li>HTTP常见状态码和含义</li>
<li>HTTP常见的Header和功能</li>
<li>HTTP和HTTPS的区别</li>
<li>Cookie和Session分别是什么，有什么区别</li>
<li>转发（Forward）和重定向（Redirect）的区别</li>
<li>描述浏览器输入url到显示页面的整个过程</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li>进程和线程的区别</li>
<li>并行和并发的区别</li>
<li>进程间通信</li>
<li>生产者消费者模型</li>
<li>什么是协程</li>
<li>死锁产生的条件和解决死锁的办法</li>
</ol>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li>哪些命令和开发工具</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>什么是事务，隔离级别</li>
<li>数据库设计三范式</li>
</ol>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ol>
<li>MySQL有哪几种数据类型，char、varchar、text有什么区别</li>
<li>InnoDB和MyIsam区别</li>
<li>MySQL主从复制原理</li>
<li>InnoDB有哪几种锁，如何实现乐观锁</li>
<li>有哪几种索引，哪几种场景会命中索引</li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li>Redis有哪几种数据结构，如何使用的</li>
<li>Redis有哪些优点和缺点</li>
<li>Redis线程模型</li>
<li>Redis内存淘汰机制</li>
<li>Redis如何做持久化</li>
<li>缓存雪崩和缓存穿透分别是什么，有什么解决方案</li>
<li>如何保证缓存与数据库双写时的数据一致性</li>
<li>Redis和memchached的区别</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li>用过或知道哪些设计模式</li>
</ol>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ol>
<li>Ioc、AOP原理</li>
<li>SpringMVC原理</li>
</ol>
<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><ol>
<li>使用消息队列好处和坏处，具体使用场景</li>
<li>常见的消息队列有哪些，如何选型</li>
</ol>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ol>
<li>HDFS块</li>
<li>架构，如何保证高可用</li>
<li>读写流程</li>
</ol>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ol>
<li>有哪几个进程</li>
<li>shuffle过程</li>
<li>例子</li>
<li>如何处理数据倾斜问题</li>
<li>map数量和reduce数量如何确定</li>
</ol>
<h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><ol>
<li>Hive原理</li>
</ol>
<h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><ol>
<li>Hbase的rowKey和列族如何设计</li>
<li>Hbase和Redis使用场景</li>
</ol>
<h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ol>
<li>spark程序编写步骤</li>
<li>spark算子</li>
<li>spark rdd过程</li>
<li>shuffle过程</li>
<li>数据倾斜问题</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://juejin.im/post/5b5ac91051882519a62f72e5" target="_blank" rel="noopener">一套高级大数据开发面试题（刷起来！！！）</a></li>
<li><a href="https://blog.csdn.net/qq_16633405/article/details/78947969" target="_blank" rel="noopener">大数据面试题总结（附答案）</a></li>
<li><a href="https://blog.csdn.net/WYpersist/article/details/80102757" target="_blank" rel="noopener">Hive面试题收集</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35628199" target="_blank" rel="noopener">Python面试中90%的面试题！附带最好的回答！面试宝典</a></li>
</ol>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
      

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeffzzf.github.io/2019/08/19/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jeffzzf">
      <meta itemprop="description" content="Do one thing at a time, and do well.">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Noob">
    </span>
      <header class="post-header">

        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/19/Kafka/" class="post-title-link" itemprop="url">Kafka</a>
              
            
          </h1>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-19 15:36:48" itemprop="dateCreated datePublished" datetime="2019-08-19T15:36:48+08:00">2019-08-19</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-29 11:23:45" itemprop="dateModified" datetime="2019-08-29T11:23:45+08:00">2019-08-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/mq/" itemprop="url" rel="index"><span itemprop="name">mq</span></a></span>

                
                
              
            </span>
          

          <br>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
            <h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>Topic</strong></p>
<p>主题，承载消息的逻辑容器，在实际使用中用于区分业务类型。</p>
<p><strong>Record</strong></p>
<p>消息，Kafka处理的主要对象</p>
<p><strong>Partition</strong></p>
<p>分区，每个topic包含一个或多个partition，是一个有序的消息序列。物理上，每个partition对应一个文件夹，该文件夹下存储该partition的数据和索引文件。每条消息被发送到broker之前，会根据分区规则选择存储到哪个分区。</p>
<p><strong>Offset</strong></p>
<p>消息位移，表示分区中每条消息的位置信息，是一个单调递增且不变的值。offset是消息在分区中的唯一标识，kafka通过offset来保证消息在分区中的顺序性，kafka保证的是分区有序而不是主题有序。</p>
<p><img src="/images/image-20190819170404800.png" alt="image-20190819170404800"></p>
<p>几种重要的offset：</p>
<ul>
<li>LogStartOffset，第一条消息的offset，等于0</li>
<li>HW（High Watermark），高水位，标识特定的offset，消费者只能拉取这个offset之前的消息</li>
<li>LEO（Log End Offset）标识当前日志文件下一条待写入消息的offset，等于当前日志分区最后一条消息offset加1</li>
</ul>
<p>分区ISR集合中的每个副本都会维护自身的LEO，ISR集合中最小的LEO即为分区的HW。Kafka的复制机制既不是同步复制也不是异步复制，这种ISR的方式有效权衡了数据可靠性和性能之间的关系。</p>
<p><strong>Replica</strong></p>
<p>副本，同一条消息被拷贝到多个地方以提供数据冗余，副本分为leader replica（领导者副本）和follower replica（追随者副本）。副本是在分区层级下的，即每个分区可以配置多个副本实现高可用。生产者和消费者只和leader副本交互，follower副本只负责消息同步。副本处于不同的broker中，当leader副本出现故障时，从follower副本中重新选举新的leader副本对外提供服务。</p>
<p>分区中的所有副本统称为AR(AssignedReplicas)。所有与leader副本保持一定程度同步的副本(包括leader副本在内〕组成ISROn-SyncReplicas),ISR集合是AR集合中的一个子集。消息会先发送到lead巳r副本，然后follower副本才能从leader副本中拉取消息进行同步，同步期间内follower副本相对于leader副本而言会有一定程度的滞后。“一定程度的同步”是指可忍受的滞后范围，这个范围可以通过参数进行配置。与leader副本同步滞后过多的副本(不包括leader副本)组成OSR(Out-of-SyncReplicas)，由此可见，AR=ISR+OSR。在正常情况下，所有的follower副本都应该与leader副本保持一定程度的同步，即AR=ISR,OSR集合为空。</p>
<p>leader副本负责维护和跟踪ISR集合中所有follower副本的滞后状态，当follower副本落后太多或失效时，leader副本会把它从ISR集合中剔除。如果OSR集合中有follower副本“追上”了leader副本，那么leader副本会把它从OSR集合转移至ISR集合。默认情况下，当leader副本发生故障时，只有在ISR集合中的副本才有资格被选举为新的leader，而在OSR集合中的副本则没有任何机会(不过这个原则也可以通过修改相应的参数配置来改变)。</p>
<p><strong>Producer</strong></p>
<p>生产者，向主题发布新消息的应用程序</p>
<p><strong>Consumer</strong></p>
<p>消费者，从主题订阅新消息的应用程序。kafka consumer使用拉（pull）模式从服务端拉取消息，并保存消费的具体位置。消费者宕机恢复后可根据之前保存的消费位置重新拉取需要的消息进行消费以避免消息丢失。</p>
<p><strong>Consumer Offset</strong></p>
<p>消费者消费进度，每个消费者都有自己的消费者位移</p>
<p><strong>Consumer Group</strong></p>
<p>多个消费者实例组成一个组，同时消费多个分区以实现高吞吐</p>
<p><strong>Rebalance</strong></p>
<p>重平衡，消费者组内某个消费者实例挂掉后，其它消费者实例自动重新分配订阅主题分区的过程，是Kafka消费端实现高可用的重要手段</p>
<p><strong>Broker</strong></p>
<p>服务代理节点，大多数情况下，broker可以看作一台kafka服务器，前提是这台服务器上只部署了一个kafka实例</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Kafka通过ZooKeeper对元数据进行管理，包括集群、broker、主题、分区等内容。</p>
<p><img src="/images/KafkaArchitecture.png" alt="kafka architecture æ¶æ"></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">    producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"my-topic"</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line"></span><br><span class="line">producer.close();</span><br></pre></td></tr></table></figure>

<p>KafkaProducer是线程安全的，在多个线程中使用同一个producer会有更高的性能。</p>
<p>send本身就是异步的，有两个重载的方法，返回的Future对象可以使调用方稍后获得发送的结果。发送消息一般可能发生两种异常：可重试异常和不可重试异常。常见的可重试异常有NetworkException、LeaderNotAvailableException、UnkonwnTopicOrPartitionException、NotEnoughRepicaException。常见的不可重试异常如RecordTooLargeException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span>;</span><br><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对于可重试异常，如果配置了retries参数，只要在规定重试次数内自行恢复就不会抛出异常。默认值是0，配置方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ProducerConfg.RETRIES_CONFIG, <span class="number">3</span> ) ;</span><br></pre></td></tr></table></figure>

<p>send方法将消息发送给broker时，有可能经过拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）后才真正发往broker。</p>
<p><img src="/images/image-20190819220846252.png" alt="image-20190819220846252"></p>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>生产者拦截器可以用来在消息发送前做一些准备工作，如按照某个规则过滤不符合要求的消息、修改消息内容等，也可以做一些定制化的需求，如统计类工作。KafkaProducer不仅可以指定一个拦截器，还可以指定多个拦截器组成拦截链。拦截链中，如果某个拦截器执行失败，下一个拦截器会接着从上一个执行成功的拦截器继续执行。</p>
<h4 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h4><p>生产者发送数据时需要通过序列化把对象转换成字节数组，消费者消费消息时要使用与生产者序列化器兼容的反序列化器将字节数组转化为对象。如果Kafka客户端提供的几种序列化器都无法满足需求，可以选择使用Avro、JSON、Thrift、ProtoBuf等通用的序列化工具来实现，或者使用自定义的序列化器实现。</p>
<h4 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h4><p>分区器的作用是为消息分配分区，如果消息ProducerRecord中没有指定partition字段，producer将根据key来计算partition的值。如果key不为null，默认的分区器对key进行hash（采用MurmurHash2算法），相同key对应的消息会被写入同一个分区。如果key为null，消息将会以轮询的方式发往主题内各个可用分区。</p>
<h4 id="消息收集器"><a href="#消息收集器" class="headerlink" title="消息收集器"></a>消息收集器</h4><p>生产者客户端由两个线程协调运行：主线程和Sender线程。在主线程中创建消息、通过可能的拦截器、序列化器和分区器后缓存到消息累加器（RecordAccumulator，也称作消息收集器）中。Sender线程从RecordAccumulator中获取消息并将其发送到Kafka中。</p>
<p>RecordAccumulator主要用来缓存消息以便于Sender线程可以批量发送，进而减少网络传输资源的消耗以提升性能。缓存大小可以通过生产者客户端参数buffer.memory配置，默认值为32MB。如果生产者发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，send()方法要么被阻塞要么抛出异常。该特性由参数max.block.ms配置，默认值为60s。</p>
<p>RecordAccumulator内部为每个分区都维护了一个双端队列，消息写入缓存时，追加到双端队列的尾部；sender读取消息时，从双端队列的头部读取。InFlightRequests会缓存已经发出去但还没收到响应的请求，并通过还未确认的请求计算负载最小的Node（leastLoadedNode）。</p>
<h4 id="元数据更新"><a href="#元数据更新" class="headerlink" title="元数据更新"></a>元数据更新</h4><p>元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的lead巳r副本分配在哪个节点上，follower副本分配在哪些节点上，哪些副本在AR、ISR等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。</p>
<p>当客户端中没有需要使用的元数据，如没有指定主题信息或超过metadata.max.age.ms（默认5分钟）时间没有更新元数据都会引起元数据的更新操作。元数据更新操作在客户端内部进行，对客户端外部使用者不可见。更新元数据时，先挑选出leastLoadedNode，向这个Node发送MetadataRequest请求获取元数据信息。这个请求由Sender线程发起，主线程也需要读取这些信息，它们之间通过synchronized和final关键字来保证。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>每个消费者（Consumer）对应一个消费组（Consumer Group），可以通过增加/减少消费者个数来提高/降低整体消费能力。当消费者个数大于分区个数时，会有消费者分配不到任何分区。</p>
<p>消息中间件一般有两种消息投递模式：点对点模式（P2P，Point-to-Point）模式和发布/订阅（Pub/Sub）模式。发布/订阅模式在一对多广播时采用。Kafka同时支持两种消息投递模式，当消费者都属于不同的消费组时，所有消息被广播给所有消费者，每条消息都会被所有消费者处理，相当于发布订阅模式；当所有消费者都属于同一个消费组时，每个消息只会被一个消费者处理，相当于点对点模式。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解Kafka：核心设计与实践原理》</p>

          
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
    </footer>
  </div>
  
  
  
  </article>

    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jeffzzf</p>
  <div class="site-description motion-element" itemprop="description">Do one thing at a time, and do well.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">121</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">107</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeffzzf</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.3.0</div>

        








        
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>

    

  </div>

  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  <script src="/js/utils.js?v=7.3.0"></script>
  <script src="/js/motion.js?v=7.3.0"></script>

  
  <script src="/js/schemes/muse.js?v=7.3.0"></script>


  

  <script src="/js/next-boot.js?v=7.3.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

  

  

  


  





  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  
































</body>
</html>
